Monitoring-managing-linux-processes


El proceso del SO es llamado systemd con el PID 1 es el primero que se genera
Es el que origina el SO
En RHEL 6 hacia abajo es llamado init

Este genera procesos hijos (child process) y terminado pasa a un estado zombie
El estado zombie comienza a liberar recursos sin ser uzados pero mantiene el PID

Al generar los child process tambien genera parent process que esperan a los child para poder ejecutarse.

Se debe de tratar el menor numero de procesos zombie
Para corregirlos se deben mantener actualizados los parches de kernel y SO

El espacio de memoria que se asigna al iniciar el proceso se llama FORK
Luego se va programar
Luego va a pasar a un estado Run Listo
 - Se puede pasar al kernel para ejecutarse en estado R
 - Se puede detener o esperar en un Estado T (CTRL Z o CTRL C)
Cuando Esta ejecutandode en el kernel puede este pasar a un estado de sleep
 - En estado S Es  un estado interrumpible, es decir que aun se puede parar
 - En estado D Es un initerrumpible es de cir que no se puede parar
 - En estado k es un estado similar al s pero que aun se puede parar con un kill
En el kernel tambien puede estar interantuar con el usuario y sigue en estado R
Despues de ejecutarse paa a un estado Z zombie 
Despues de zombie pasa a un estado X que es exit zombie que al ser tan rapido y automativo, no se ve en los utilitarios

COAMNDO PROCESOS
----------------------------

ps aux | less
USER - PID - %CPU - %MEM - VRZ - RSZ - STADO

top
Es como el task manager de windows

SHIFT + M para ver procesamiento en memoria
SHIFT + P para ver procesamiento en CPU


ESTADO
----------------------------


CONTROLANDO TAREAS Y SESIONES
------------------------------

Ejecutar comandos qyue van a simular tareas

Al ejecutar sleep 1000 &
Al ejecutar sleep 1000 &
Al ejecutar sleep 1000 &
Al ejecutar sleep 1000 &

Comando jobs veo esas tareas en lanzadas
ps -aux | grep sleep para ver el estado del proceso

fg %1 lo trae a pantalla a primer plano (for ground) y puedes
CTRL + Z para pausarlo
CTRL + C para terminarlo
jobs nuevamente para ver las tareas

bg %1 lo manda a background y lo continua
ps -aux | grep sleep para ver el estado del proceso
jobs nuevamente para ver las tares

tty puedo ver en que pseudoterminal estoy trabajando

Simulando una tarea continua:
(while true; do echo -n "rock " >> ~/outfile; sleep 1; done)
(indica que mientras sea verdadero; 
va a escribir rock en un archivo ~/outfile; 
va a esperar 1 segundo; 
con done cierra el bucle)

(while true; do echo -n "and " >> ~/outfile; sleep 1; done)
(while true; do echo -n "roll" >> ~/outfile; sleep 1; done)













